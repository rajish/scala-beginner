<p>Język Scala posiada możliwość zdefiniowania samodzielnych funkcji, tak jak to ma miejsce w C++, a niemożliwe jest w Javie, gdzie musimy posiłkować się metodami statycznymi.

Jest wiele sposobów na zdefiniowanie funkcji lub wartości funkcjopodobnych. <br />
</p>
<!--more-->

Funkcja wywiedziona (ang. <em>implicit</em>):
<pre rel="Scala">
def id(x : Int) : Int = x

println(id(3))
// Wypisuje:
// 3
</pre>

Funckja anonimowa:
<pre rel="Scala">
val anonId = (x : Int) => x

println(anonId(3))
// Wypisuje:
// 3
</pre>

Obiekt lub klasa z metodą <code>apply</code>
<pre rel="Scala">
object Id {
  def apply(x : Int) = x
}

// f(x) => f.apply(x)

println(Id.apply(3))
println(Id(3))
// Wypisują:
// 3

class Identity {
  def apply(x : Int) = x
}
val myId = new Identity
println(myId.apply(3))
println(myId(3))
// Wypisują:
// 3

// anonimowa klasa z metodą apply:
val myOtherId = new {
  def apply(x : Int) = x
}
println(myOtherId(3))
// Wypisuje:
// 3

</pre>


Funkcje wieloargumentowe:
<pre rel="Scala">
def h(x : Int, y : Int) : Int = x + y

// Funkcja rozwijana (ang. Curried)
def hC (x : Int) (y : Int) : Int = x + y

// źle: hC 3 4
// dobrze: hC (3) (4)

// źle: hC (3)
// dobrze: hC (3) _

// źle: hC _ (4)
// dobrze: hC (_:Int) (4)

val plus3 = hC (_:Int) (3)
val plus_3 = hC (3) _

println(plus3(10))
// Wypisuje:
// 13
</pre>

Procedura (funkcja zwracjąca domyślnie zmienną typu <code>Unit</code>):
<pre rel="Scala">
def proc(a : Int) {
  println("Jestem procedurą!")
}

proc(10)
// Wypisuje:
// Jestem procedurą!
</pre>

Funkcja bezargumentowa:
<pre rel="Scala">
def argless : Unit = println("zawołano bezargumentową")

argless
argless
// wypisuje:
// zawołano bezargumentową
// zawołano bezargumentową
</pre>

Pola typu <code>lazy</code> są bezargumentowymi funkcjami, które agregują swój wynik:
<pre rel="Scala">
class LazyClass {
  lazy val x = { println("Obliczam x") ; 3 }
}

val lc = new LazyClass
println(lc.x)
println(lc.x)
println(lc.x)
// Wypisuje:
// Obliczam x
// 3
// 3
// 3
</pre>
